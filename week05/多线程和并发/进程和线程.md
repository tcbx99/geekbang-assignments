# 线程和进程定义

1. 线程是操作系统最小的调度单位（Linux 中实际的调度器调度的是线程）
2. 进程是程序执行过程中资源管理和分配的单位（这不止是一个 CPU 分配概念，还包括内核句柄和独立的用户态内存空间）
3. 协程（截止 Java 17 在 Java 世界中不存在，但 JDK 18 似乎有了）是应用程序内部的一个调度单位，协程的调度无需操作系统内核参与

# 线程进程有什么区别呢？

* 线程共享进程的用户态地址空间

  * Java 世界中，体现为所有进程有一个共享的堆
* 所有线程共享进程的所有资源，但不同进程的资源是独立的

  * 例如，多个进程不能同时写入同一个文件，但是单进程内部的多个线程可以同时操作同一个文件句柄（当然这样可能是不安全的）
  * 例如，Linux 系统中通过命名空间和 cgroup 的方式可以限制进程的总体资源用量和 IO 权限，但不能细粒度地对执行线程进行控制，Linux 系统的资源管理也并不约束某线程的用量，一切配额都以进程为单位（当然，单个进程的最大线程数也是一个资源）
* 其他“特殊点”（它们只是上述区别所导致的结果，并非原因）

  * 例如，单个线程的执行结果对其他线程也会产生影响（例如出现错误），但进程之间影响较小（在资源分配合理的情形，甚至不会发生进程之间的影响）
  * 例如，线程不能独立执行，必须依托应用程序的多线程执行控制；进程是可以独立执行的。

    * 特别地，由于 Linux 系统中特殊的 `fork()` 系统调用，这导致了进程的执行入口不一定只有一个，部分进程（例如，nginx 中的 worker 进程）也依托其他进程运行
  * 例如，进程切换时的开销远大于线程切换

# 线程进程的相同点和联系

相同点：它们都是并发的

联系：

* （用户态）线程必须属于某个进程
* 线程依托于进程来执行（所有线程共享其所述进程的资源）

# 上下文切换

上下文切换，主要是在 CPU 上切换不同任务的执行环境。包括进程的上下文切换及线程的上下文切换

## 进程的上下文切换

1. 挂起进程，将其上下文信息存入 PCB（注意，这里同时也会切换页表和内核执行状态）
2. 执行调度，找到下一个进程的上下文信息并恢复
3. 跳转到进程被中断时的代码行，恢复进程

## 线程的上下文切换

1. 挂起线程，将其上下文信息存入 PCB
2. 执行调度，找到下一个线程的上下文信息并恢复
3. 跳转到线程被中断时的代码行，恢复线程

## 上下文切换的原因

1. 做完了
2. 阻塞（IO、没有抢到互斥锁、其他）
3. 系统调用让出
4. 硬件中断

## 性能影响

上下文切换时，CPU 缓存会被清空，这对性能的影响非常巨大（只要进行了切换就影响巨大）；同时，保存、恢复页表，修改内核中相关对象的状态在上述影响的基础上又一次增大了切换开销，导致进程上下文切换的性能影响大于线程。

# 并发和并行

* 并行指两件事情同时发生了（线程同时执行），一般是多核处理器不同核心同时执行不同线程，不存在竞争和等待的概念
* 并发指两件事情互相抢占复用同一个资源（线程并发执行），一般指一个处理器单个核心在不同线程之间切换复用。并发在宏观层面（例如，用户盯着屏幕）就像是真的并行了一样，但实际上线程是序列处理了（吃一口薯条再吃一口炸鸡，薯条炸鸡都少了，就像是一边吃炸鸡一边吃薯条一样）

  * 此时，会出现资源的竞争和等待
