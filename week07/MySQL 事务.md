# 先讲讲需求，我们为什么需要事务

## 事务是什么？

事务是指单个逻辑工作单元执行的一系列操作，要么都做，要么都不做，是不可分割的工作单位。

事务包含四个特性：

* 原子性：要么成功要么失败
* 隔离性：完成前对其他事务不可见
* 一致性：事务操作前后，表中数据（要更改的数据）不会变化
* 持久性：一旦提交永久生效

那么，为啥要这东西呢？来看看 NoSQL 中是怎么干掉事务的。

## CAP 和 ACID

CAP 原则中，对分布式系统有如下要求：

* 所有节点同一时间数据相同
* 不管成功还是失败都要有响应
* 信息丢失、失败系统不会死

布鲁尔定理指出，这仨要求只能满足两个（对于分布式系统来说），导致大多数情况下，很多 NoSQL 都只有最终一致性，也就是 BASE 原则：

* 基本可用
* 柔性事务，面向无状态
* 最终一致性

## 事务的目标是复杂的业务

### 事务的隔离级别，以及为啥隔离

* 读未提交：一个事务在写数据时，不允许另外一个事务进行写操作，但允许读操作。这样避免了更新丢失，却可能出现脏读。
* 提交读：写事务提交之前不允许其他事务的读操作，可以解决脏读问题。但会出现一个事务范围内两个相同的查询却返回了不同数据（不可重复读）和幻读。

  * 例如，我先扣100元，但是我太慢了 ，没有闪，对面在这期间已经扣了我200，导致我没余额了
* 可重复读：事务开启时，不再允许修改操作，这样就可以在同一个事务内两次读到的数据是一样的，因此称为是可重复读隔离级别，但是有时可能会出现幻读。

  * 查询订单，的确是上锁了，但是事务期间另一个事务又加了一条订单进去，导致数据的不一致

* 可序化：事务不能并发执行。会导致上锁读（事务顺序执行）

### 

|<br />|脏读|不可重复读|幻读|读上锁|性能|
| ----------| ------| ------------| --------| --------| -------------|
|读未提交|Y|Y|Y|N|无锁|
|提交读|N|Y|Y|N|行锁|
|可重复读|N|N|Y（N）|N|间隙锁+行锁|
|序列化|N|N|N|Y|串行表锁|

‍
