*内容使用思源笔记编写，若您也使用思源笔记，可以下载 .sy.zip 文件导入获得更好的阅读体验。*

# Java 内存是什么？

>
>

## 数据区

>
>

### 堆

> *TL;DR: 你用了 new T()，new 出来的东西在堆里，栈里只有一个指针。程序员管杀不管埋，用不到的东西虚拟机会吃掉*
>
> 堆是 Java 执行环境中最主要的内存区域。对象（以及数组）存储在这里。堆里的内容由 Java 执行环境进行管理（管它是 Hotspot，OpenJ9，Dalvik 还是 ART），用户创建出来之后，不需要显式维护其生命周期（**这并不代表 Java 不存在内存泄露，Java 的内存泄露反倒是因为其隐式的生命周期维护**），在对象不再被**强**引用时，对象应当**能够**被回收（回收的对象可以是弱引用的）。
>
> # Hotspot 虚拟机对堆的维护：年轻代和老年代
>
> *注意：本段内容仅适用于 Hotspot 虚拟机*
>
> Hotspot 虚拟机为了减少垃圾回收的开销，将堆内存进行了分代，由年轻代和老年代组成。两代的 GC 实现不同，年轻代进行 Minor GC，老年代进行 Major GC。
>
> ## 理论基础
>
> *请看这里：[Generations (oracle.com)](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#distribution_lifetimes)*
>
> Hotspot 的开发者认为，对象的生命周期有两个关键特性（统计学）：
>
> * 弱分代：绝大多数对象都是临时对象，能够经历的 GC 次数非常少
> * 强分代：GC 次数越多的对象被下一次 GC 回收的概率越低
>
> 所以，根据上述假说，我们可以得到两个内存布局的设计方式：
>
> * 年轻代：因为大多数对象都是“朝生夕灭”的，我们直接搞出一大块内存，等到装满了的时候，将所有活下来（未被回收）的对象拷贝到其他地方去，之后这块内存直接给下一轮新对象去用
>
>   * 理解：因为年轻的对象消灭的比存活的少，比起对垃圾进行标记清除，还不如直接屎里淘金，然后按下冲水键
> * 老年代：因为能够经历很多次 GC 的对象更不容易被消灭了（还少），可以把它们放在一起，年轻代爱 GC 就 GC，老年代满了再标记清除（无法判断老年代中垃圾比率，而且对象数量也少）
> * 由于年轻代中，也不是所有的临时对象都只能活一天（有的是两天），最好安排个专属地方住（Survivor）
>
> ## Hotspot 各个版本的内存分区
>
> ### JDK 1.7
>
> * Young: 年轻代，一个 Eden，两个 Survivor
> * Tenured: 老年代，年长对象
> * Perm: 保存元对象，例如类、方法等，正常写程序不会出问题，但是 ByteBuddy + Silly Developer (like me) = OutOfMemoryError: PermGen space
>
>   * 之前写的字节码增强 Bean Copy 轮子炸掉了元空间（虽然是 Java 8）
>
>     * 后来改用 MapStruct，构建时生成代码，美滋滋
> * Virtual: 没用到的内存在这里
>
> ### JDK 1.8
>
> * 永久代变为元空间，改为放置在堆外内存中
> * 堆里只剩下新生代和老年代了
>
> ### JDK 1.9
>
> * 进行内存分块，将物理分区改为逻辑分区
>
>   * 这是为了对老年代进行并发回收（参见 G1）
> * 由于大对象不能进行放在一个块里，增加了 Humongous 区
>

### 虚拟机栈

> 栈是线程私有的，与所属的线程同生共死。Java 方法执行会增加栈帧，栈帧大小在方法的字节码中进行了说明
>
> ## Java 规范中的栈帧
>
> *温馨提示：Android 众退散，这里没在说 Smali*
>
> Java 是栈式虚拟机，在字节码 OpCode 中，是不存在寄存器的，所以，一个简单的 1 + 1，在虚拟机中的执行方式如下（使用 IDEA 字节码插件）：
>
> ```
> // class version 58.0 (58)
> // access flags 0x21
> public class hero/Main {
>
>   // compiled from: Main.java
>
>   // access flags 0x1
>   // 这里是类的初始化方法
>   public <init>()V
>    L0
>     LINENUMBER 3 L0
>     ALOAD 0
>     INVOKESPECIAL java/lang/Object.<init> ()V
>     RETURN
>    L1
>     LOCALVARIABLE this Lhero/Main; L0 L1 0
>     MAXSTACK = 1
>     MAXLOCALS = 1
>
>   // access flags 0x9
>   // 加法方法
>   // public static int add(int a, int b) -> a + b;
>   public static add(II)I
>    L0                             //+ Label L0
>     LINENUMBER 6 L0               // 行号标识
>     ILOAD 0                       // 将第 0 个局部变量入栈
>     ILOAD 1                       // 将第 1 个局部变量入栈
>     IADD                          // Push(Pop() + Pop())
>     IRETURN                       // return Pop()
>    L1                             //+ Label L1
>     // 注意，Java 中方法的参数直接进入局部变量区的首部
>     LOCALVARIABLE a I L0 L1 0     // 变量 `a`, 整形(I), 生命周期 L0-L1, 位置 0
>     LOCALVARIABLE b I L0 L1 1     // 变量 `b`, 整形(I), 生命周期 L0-L1, 位置 1
>     MAXSTACK = 2                  // 栈最大大小
>     MAXLOCALS = 2                 // 本地变量最大大小
>
>   // access flags 0x9
>   // Main 测试函数
>   public static main([Ljava/lang/String;)V
>    L0
>     LINENUMBER 10 L0                    // 行号标识
>     ICONST_1                            // Push(1)
>     ICONST_1                            // Push(1)
>     // Push(Invoke(hero.Main#add(int,int)))
>     // (II) 代表参数是栈顶的两个整型变量
>     INVOKESTATIC hero/Main.add (II)I
>     ISTORE 1                            // 将栈顶推出，存入第 1 个局部变量
>    L1
>     LINENUMBER 11 L1                    // 行号标识
>     // 将 `java.io.PrintStream java.lang.System.out` 放入栈顶
>     GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
>     ILOAD 1                             // 将第 1 个局部变量入栈
>     INVOKEVIRTUAL java/io/PrintStream.println (I)V
>    L2
>     LINENUMBER 12 L2                    // 行号标识
>     RETURN                              // return void
>    L3
>     // 第一个局部变量是 `main` 函数的参数
>     LOCALVARIABLE args [Ljava/lang/String; L0 L3 0
>     LOCALVARIABLE c I L1 L3 1           // 第二个局部变量是 `c`
>     MAXSTACK = 2                        // 栈中最大元素为 2，因为调用函数都出栈了
>     MAXLOCALS = 2                       // 最大变量 2
> }
>
> ```
>
> 栈里存储了所有 Java 基本类型的**值**，包括 `boolean`, `int`, `long`, `double`, `float`, `char`, `byte`, `reference` 类型。其中，Reference 类型是对象的引用（可以认为是指针）。
>
> ## 栈爆炸了
>
> * 如果调用深度太大，导致给方法栈分配的空间爆炸了，则抛出 `java.lang.StackOverflowError`
> * （测试于 Red Hat 编译的 OpenJDK 8）方法栈不在堆里，太多的线程会炸掉本地内存，造成操作系统 OOM（HotSpot 带着所有负载一起上天）
>
>   * 不能排除是 Java 进程触发了最大线程限制导致的问题
>
> ## Java 栈和本地方法栈
>
> 注意，Java 的方法栈和本地方法栈类似（而不是相反），本地方法栈是 libc 提供的本地方法（函数）运行的环境，JVM 和你自己写的本地方法都运行在上面。
>

### 方法区

> # 存啥
>
> * Class
>
>   * Method
>   * Field
>   * ~~类变量~~（JDK 1.7+ 放到堆里了）
>   * 方法表
> * ~~常量池（字符串常量池）~~（JDK 1.7+ 放到堆里了）
> * JIT 代码缓存
>
> # 永久代和元空间
>
> *Reference: [JEP 122: Remove the Permanent Generation](https://openjdk.org/jeps/122)*
>
> 不同点：
>
> * 永久代在 JVM 内存空间（堆空间限制）中，元空间不受堆空间限制控制（使用堆外空间）
>
>   * 你可以通过参数的方式限制元空间大小，否则 Linux OOM 比 OutOfMemoryError 恐怖太多
> * 元空间只存储类的元信息
>
>   * 元空间存储 Klass 信息，默认放在 Compressed Class Pointer Space 中
>   * 元空间还会存储方法、常量池等信息
>
> # 字符串常量池
>
> String 常量在 JVM 内部是一个 StringTable，保存所有字符串的引用。StringTable 本质上是一个 HashTable，退化为链表（冲突处理）
>
> 注意：只有常量和你自己 `String.intern()` 的字符串会在里面，其他的都在堆里；当然，`String` 的拷贝构造函数会复用底层数组。
>
> 例如：`new String("hello".toCharArray())` 对象和底层数组都在堆里，但是 `new String("hello")` 则会发生新对象和常量对象共用底层数组的现象。
>

### 常量池

> * Class 常量池，在 Class 文件里
>
>   * 字面量，符号引用（Class、Method、Field 等）
> * 运行时常量池，在内存里
>
>   * 同上，只不过都在内存里
> * 字符串常量池[^1]
>

## 直接内存

> 它们不在 JVM 规范中，一般可能是使用了 Unsafe 对象，或者使用了 JNI 才会出现。
>


# Java 对象和垃圾回收

> # 对象是甚么？在内存里怎么表示？
>
> * 对象头
>
>   * MarkWord
>
>     * 对象的关键数据（例如用于实现轻量级锁和偏向锁）
>     * 其他数据（Hashcode，GC 分代年龄，锁状态等）
>     * 大小非固定
>     * 建议不要关注此类开销，因为这部分内容**不是稳定的**，随着 JVM 的发展或是替换实现（例如 OpenJ9），不能保证仍然和本文所述相同
> * 实例数据：所有非静态成员，基本类型为值，对象为引用
>
>   * 基本数据类型直接占用空间，例如 `boolean` 和 `byte` 为1，`long` 为 8
>   * 对象（包括包装类的对象）直接占用 4 字节
> * ~~Padding~~（补足 8 Byte）
>
>   * 用于压缩指针
>
> # 对象的访问
>
> * 句柄：通过句柄池类似于 `**p` 的形式查找
>
>   * 优点：对象被移动（GC）时只需要修改句柄
>   * 缺点：两次跳转
> * 直接指针：`*p` 的形式
>
>   * 优点：节省一次 查找
>

## 对象的创建

> * 我要 new 一个对象
> * JVM: 看看常量池
>
>   * 如果常量池中有对应 Class，直接使用
>   * 否则委托给加载此类的 ClassLoader
> * 分配空间[^2]（指针碰撞或空闲列表，需要加锁）
> * Zero
> * 写对象头
> * init
>
> # 分配方式
>
> 连续内存的话，可以使用指针碰撞法，记录最后一次分配；否则，则使用空闲列表。
>
> ## 安全吗？
>
> JVM 解决方案：
>
> * CAS 加锁，失败重试
> * TLAB，每线程预先分配一块内存（还记着这里[^3]吗？可以使用 TLAB 也是因为新生代几乎没有内存碎片）
>
> 先尝试在 TLAB 中分配，然后（如果 TLAB 无法容纳）判断将对象放入老年代还是共享的新生代
>
> ## 过程
>
> * Eden 有地方吗？
>
>   * 有，结束
>   * 没有，Young GC 一下
>
>     * Eden 或 S0/S1 有地方吗？
>
>       * 有，结束
>       * 没有，尝试晋升老年代
>
>         * **老年代可以分配，结束**
>         * 老年代不能分配，Full GC
>
>           * **可以分配，结束**
>           * 不可以分配，OOM
>
> 粗体字表明，JVM 直接将对象分配到了老年代。
>
> ### 内存担保机制，以及对象怎么直接进入老年代？
>
> 进入老年代条件有三个（说三实四）：
>
> * GC 次数大于 MaxTenuringThreshold（默认为 15）
> * 动态年龄：Survivor 区有一批对象总大小超过了该区 50%，则大于等于这批对象年龄的对象直接晋升
>
>   * *我们需要让可能长期存活的对象别在那里复制来复制去了*
>   * 通过 TargetSurvivorRatio 指定这个值
> * 超重：大对象直接进入老年代（G1 会不会？）
>
>   * 使用 PretenureSizeThreshold 指定
>   * *大对象复制来复制去还不如标记清除呢*
> * Minor GC 后 Survivor 区无法承担，使用内存担保。
>
>   * Minor GC 前，先判断老年代是否可以容纳 0% GC 的情形（即全部复制），再判断**老年代最大的连续空间，是否大于历次晋升到老年代的对象的平均大小**。
>
>     * 如果能够容纳 0% GC 的情形，则直接 Minor GC 后放入老年代
>     * 否则进行“**内存担保**”，也就是第二个判断
>
>       * 如果第二个判断为真，冒险进行一次 Minor GC，再重试一次（节省一次 Full GC）
>       * 否则进行 Full GC，若还放不下就 OOM
>

## 对象的销毁和垃圾回收

> # 为什么要回收垃圾
>
> 这里[^4]说到了，用来避免开发者手动控制生命周期。
>
> 注：还用压测？即使在请求量少，新对象创建少的情况，也知道一个事情，那就是不做减法只做加法，内存总是会被占满的。
>
> # 你是什么垃圾
>
> 简单的垃圾分类：不用的东西就是垃圾。
>
> 曾经的（没有垃圾收集的上古时代）垃圾定义：被用户手动标记为垃圾的就是垃圾
>
> ```c
> void test ()
> {
>     void *p = malloc (0x300);
>     /* 用完记得扔掉 */
>     free (p);
> }
> ```
>
> 那么会出现一个问题，程序员分配内存空间和销毁内存空间所在的程序上下文可能是不一样的（对象会在多个过程中传递），导致了很多时候程序员会忘掉某种情况下将这块空间释放掉（就像你的桌子，放了很多很多东西，自己都忘掉了哪个需要哪个不需要了一样）。此时，需要一个垃圾回收器，帮助程序员判断内存空间（Java 中为对象）是否不再被使用（Rust 采用了另一种方法，通过限制对象的生命周期来进行，这就是后话了）。
>
> ## 什么是不再被使用了？
>
> 严格来说，对于目前运行的程序，绝对不可达的对象一定是垃圾。
>
> ```java
> String c = new String("hello");
> System.out.println(c);
> c = null; // c 是垃圾
> ```
>
> 如何表明可达但不用的对象？Java 提供了引用全家桶 `java.lang.ref.*`
>
> 所以，在 Java 中，不再被程序可达的强引用的对象就是垃圾。
>
> * 被可达的对象强引用的对象也是可达的对象
> * 被可达的对象弱引用的对象可以是垃圾
>
> ## 如何找到垃圾
>
> ### 引用计数法，以及为啥不好用
>
> 最好想的办法，就是引用计数了。C++ 中的智能指针也使用的是引用计数法。
>
> **注意：C++ 智能指针绝对不可以当作 Java 的引用来用！**
>
> 具体实施：
>
> * 每一次引用，给计数器 +1
> * 每一次解引用，给计数器 -1
> * 计数器为 0 时，你是垃圾
>
> 问题：A 对象和 B 对象互相引用，然后被抛弃了（不可达），可是它们还互相引用，导致内存泄露。
>
> **C++ 使用智能指针的情形，循环引用需要开发者自己特别处理！**显然，Java 世界中，不可以这么做。
>
> ### 根可达算法
>
> 从 GCRoot 开始搜索，路径称作引用链，不在链上的全部是垃圾（它们不再可达，或者不被强引用了）
>
> Java 中的 GCRoots：
>
> * 所有线程栈（Java 栈）中引用的对象
> * 方法区中引用的对象（常量引用或静态成员的引用）
> * JNI 的引用（**注意：这里是导致 Java 内存泄露的可能原因之一**）
>
> ## Java 中，垃圾也是可以缓刑的
>
> Java 中的对象要被回收需要经历两次标记
>
> * 第一次，对象不可达
> * 第二次，执行了 `finalize()` 方法后，仍然不可达（最多执行一次）
>
> 只有两次都成功标记了，对象才会被回收
>
> ### 别用这东西！
>
> 1. 这玩意不一定被执行，只有 GC 的时候才回去碰
> 2. 这玩意阻止了 GC，损失性能（关键是 1 里这玩意还不靠谱）
> 3. 即使构造函数抛出了异常，重写了终结方法的对象还会继续存在，**这个很危险！**
>
> 一种适用类型：`java.io.FileInputStream` 中 重写：
>
> ```java
>     /**
>      * Ensures that the <code>close</code> method of this file input stream is
>      * called when there are no more references to it.
>      *
>      * @exception  IOException  if an I/O error occurs.
>      * @see        java.io.FileInputStream#close()
>      */
>     protected void finalize() throws IOException {
>         if ((fd != null) &&  (fd != FileDescriptor.in)) {
>             /* if fd is shared, the references in FileDescriptor
>              * will ensure that finalizer is only called when
>              * safe to do so. All references using the fd have
>              * become unreachable. We can call close()
>              */
>             close();
>         }
>     }
> ```
>
> 另一种适用对象：本地对等体（本地也有个对象，Java 中使用一个对象映射之）
>
> 注意：本地对等体建议继承 `Closeable`，然后只用终结方法做兜底！毕竟这个方法不一定会被调用
>

### 引用类型

> |引用类型|含义|用途|回收时机|
> | --------| ----------------| --------| --------|
> |强引用|<br />|一般|永不|
> |软引用|可能使用的对象|对象缓存|内存不足<br />|
> |弱引用|极少使用的对象|对象缓存|GC<br />|
> |虚引用|销毁后要后续处理|销毁回调|GC|
>
> 例如：
>
> * 用软引用可以解决重复读取文件问题，将文件缓存到内存中
> * 用弱引用可以监控对象是否即将被回收
> * 用虚引用可以在对象被 GC 后释放对应的外部资源
>

### 垃圾回收算法

> # 标记-清除算法
>
> 先标记所有要回收的对象，然后统一回收掉
>
> 问题：
>
> * 标记和清除效率都不是很高
> * 标记清除后会有大量内存碎片，大对象无法找到连续内存空间分配
>
> # 复制算法
>
> 将空间分为两块，一块内存用完了，就标记所有存活的对象复制到另一块，然后把当前块清空。
>
> 问题：
>
> * 只有一半的可用空间
>
>   * 但是根据 GC 基本假设[^5]，实际上存放复制后存活对象的区域可以远远小于源区域
> * 复制是一件很耗时的事情
>
> Hotspot 将此算法用于新生代的 GC。
>
> # 标记-整理算法
>
> 在 标记-清除算法[^6] 的基础上，将存活对象向一端移动。
>
> 问题：
>
> * 还要复制，比标记-清除效率还低
>
> # 分代回收
>
> *参见：GC 基本假设[^5]*
>
> 新生代采用 复制算法[^7]，老年代采用 标记-清除算法[^6] 或 标记-整理算法[^8]。
>

### JVM 垃圾回收器

> * 新生代回收器：Serial[^9]，Parallel Scavenge[^10]，ParNew[^12]
> * 老年代回收器：Serial Old[^11]，Parallel Old[^13]，CMS[^14]
> * 整堆回收：G1[^15]，ZGC[^20]
>
> 垃圾回收器之间可以搭配使用的矩阵如下：
>
> |新生代|老年代|
> | --------------------| ---------------|
> |Serial[^9]|Serial Old[^11]|
> |Serial[^9]|CMS[^14]|
> |ParNew[^12]|Serial Old[^11]|
> |ParNew[^12]|CMS[^14]|
> |Parallel Scavenge[^10]|Serial Old[^11]|
> |Parallel Scavenge[^10]|Parallel Old[^13]|
>
> # 执行的 SafePoint
>
> SafePoint 是 GC 被允许挂起线程的点。
>
> * 循环末尾
> * 方法返回之前
> * 调用方法之后
> * 抛出异常时
>

#### Serial 和 Serial Old

> # Serial 收集器
>
> * 启动时 STW
> * 单线程复制
> * 单 CPU 环境（恐怕仅限此环境）效率更高
>
> # Serial Old 收集器
>
> 为 Serial 收集器[^9] 的老年代版本。单线程的 标记-整理算法[^8]。
>

#### 并行收集器

> # Parallel Scavenge 收集器
>
> `-XX:+UseParallelGC`
>
> * 吞吐量优先
> * 采用并行 复制算法[^7] 回收新生代
> * 老年代默认采用 Serial Old 收集器[^11]
>
> # Parallel Old 收集器
>
> `-XX:+UseParallelOldGC`
>
> * Parallel Scavenge 收集器[^10] 的老年版本
> * 多线程 标记-整理算法[^8]
> * *如何在多线程做到内存整理？*
>
> # ParNew 收集器
>
> `-XX:+UseParNewGC -XX:ParallelGCThreads={{n}}`
>
> * *和 Parallel Scavenge 有什么区别吗？*
>
> # CMS 收集器
>
> 注意：此收集器最新版本的 JDK 已不再建议使用
>
> `-XX:+UseConcMarkSweepGC`
>
> * 可以并发收集，且延迟低
> * 采用 标记-清除算法[^6]
> * **​CPU 敏感**
> * **产生内存碎片，导致大对象 OOM**
> * **内存不能填满后 GC**（有 GC 阈值）
>
> ## 收集 4 阶段
>
> 1. 初始标记 (Initial-Mark)
>
>    * 标记于 GCRoots 直接关联的对象
>    * 会 STW，但是时间很短
> 2. 并发标记 (Concurrent-Mark)
>
>    * 通过直接关联对象遍历对象图
>    * 不会 STW
> 3. 重新标记 (Remark)
>
>    * 修正并发标记期间的改动
>
>      * 主要是处理并发标记期间创建的新对象
>    * 会 STW，比初始标记时间更长
> 4. 并发清除 (Concurrent-Sweep)
>
>    * 清除被判断为死亡的对象并释放内存
>    * 和用户线程完全并发
>

#### G1

> 里程碑式的收集器，面向服务端，面向局部收集的垃圾回收器。
>
> 问题：
>
> * JDK 8 之后才被官方称作“全功能的垃圾收集器”
> * JDK 9 及之后才被 Oracle 设置为默认的垃圾收集器
>
> 特点：
>
> * 并行且并发
> * 多代收集（整堆收集）
> * 空间整合：局部不会产生内存碎片
> * 可预测的停顿：在效率降低的同时，可以让使用者明确指定消耗在 GC 上的时间
>
> G1 GC 的四阶段和 CMS 是一样的，不再赘述。但是 G1 有三种模式，Young GC, Mixed GC 和 Full GC，在不同条件下触发。
>
> ## 参数
>
> `-XX:+UseG1GC`
>
> `-XX:MaxGCPauseMillis=%d`: 期望达到的 GC 最大停顿时间指标[^16]，JVM 会尽力实现（默认 200 ms）
>
> `-XX:ParallelGCThreads=%d`: STW期间的GC工作线程数
>
> `-XX:ConcGCThreads=%d`: 非STW期间的GC工作线程数
>
> `-XX:G1HeapRegionSize`: Region[^17] 大小（默认 2048 块）
>
> `-XX:G1NewSizePercent`: 新生代大小下限（默认 5%）
>
> `-XX:G1MaxNewSizePercent`: 新生代大小上限（默认 60%）
>
> `-XX:InitiatingHeapOccupancyPercent`: 触发全局并发标记的老年代使用占比（默认 45%）
>
> ## 内存划分
>
> G1 收集器取消了各代的物理划分[^18]，将堆进行了分区 (Region)，分代在分区中逻辑存在。
>
> ## 局部复制
>
> G1 新生代垃圾收集还是会 STW，将存活对象拷贝到老年代或者 Survivor 空间。而复制区域的同时，G1 会完成堆的清理，不会产生内存碎片问题。
>
> 需要注意，由于短期存在的巨型对象话剧i造成影响，G1 对超过分区容量 50% 以上的巨型对象（逻辑上位于老年代）新增了一种 Humongous 区[^19]。如果一个 H 区无法容纳，则分配连续的多个 H 区容纳一个巨型对象。
>

#### ZGC

> `-XX:UseZGC`
>
> 特征：
>
> * 并发
> * 基于 Region
> * 压缩
> * NUMA 感知
> * 使用彩色指针
> * 使用负载屏障
>

[^1]: # 字符串常量池

    String 常量在 JVM 内部是一个 StringTable，保存所有字符串的引用。StringTable 本质上是一个 HashTable，退化为链表（冲突处理）

    注意：只有常量和你自己 `String.intern()` 的字符串会在里面，其他的都在堆里；当然，`String` 的拷贝构造函数会复用底层数组。

    例如：`new String("hello".toCharArray())` 对象和底层数组都在堆里，但是 `new String("hello")` 则会发生新对象和常量对象共用底层数组的现象。



[^2]: # 分配方式

    连续内存的话，可以使用指针碰撞法，记录最后一次分配；否则，则使用空闲列表。

    ## 安全吗？

    JVM 解决方案：

    * CAS 加锁，失败重试
    * TLAB，每线程预先分配一块内存（还记着年轻代：因为大多数对象都是“朝生夕灭”的，我们直接搞出一大块内存，等到装满了的时候，将所有活下来（未被回收）的对象拷贝到其他地方...[^3]吗？可以使用 TLAB 也是因为新生代几乎没有内存碎片）

    先尝试在 TLAB 中分配，然后（如果 TLAB 无法容纳）判断将对象放入老年代还是共享的新生代

    ## 过程

    * Eden 有地方吗？

      * 有，结束
      * 没有，Young GC 一下

        * Eden 或 S0/S1 有地方吗？

          * 有，结束
          * 没有，尝试晋升老年代

            * **老年代可以分配，结束**
            * 老年代不能分配，Full GC

              * **可以分配，结束**
              * 不可以分配，OOM

    粗体字表明，JVM 直接将对象分配到了老年代。

    ### 内存担保机制，以及对象怎么直接进入老年代？

    进入老年代条件有三个（说三实四）：

    * GC 次数大于 MaxTenuringThreshold（默认为 15）
    * 动态年龄：Survivor 区有一批对象总大小超过了该区 50%，则大于等于这批对象年龄的对象直接晋升

      * *我们需要让可能长期存活的对象别在那里复制来复制去了*
      * 通过 TargetSurvivorRatio 指定这个值
    * 超重：大对象直接进入老年代（G1 会不会？）

      * 使用 PretenureSizeThreshold 指定
      * *大对象复制来复制去还不如标记清除呢*
    * Minor GC 后 Survivor 区无法承担，使用内存担保。

      * Minor GC 前，先判断老年代是否可以容纳 0% GC 的情形（即全部复制），再判断**老年代最大的连续空间，是否大于历次晋升到老年代的对象的平均大小**。

        * 如果能够容纳 0% GC 的情形，则直接 Minor GC 后放入老年代
        * 否则进行“**内存担保**”，也就是第二个判断

          * 如果第二个判断为真，冒险进行一次 Minor GC，再重试一次（节省一次 Full GC）
          * 否则进行 Full GC，若还放不下就 OOM



[^3]: * 年轻代：因为大多数对象都是“朝生夕灭”的，我们直接搞出一大块内存，等到装满了的时候，将所有活下来（未被回收）的对象拷贝到其他地方去，之后这块内存直接给下一轮新对象去用

      * 理解：因为年轻的对象消灭的比存活的少，比起对垃圾进行标记清除，还不如直接屎里淘金，然后按下冲水键


[^4]: 堆是 Java 执行环境中最主要的内存区域。对象（以及数组）存储在这里。堆里的内容由 Java 执行环境进行管理（管它是 Hotspot，OpenJ9，Dalvik 还是 ART），用户创建出来之后，不需要显式维护其生命周期（**这并不代表 Java 不存在内存泄露，Java 的内存泄露反倒是因为其隐式的生命周期维护**），在对象不再被**强**引用时，对象应当**能够**被回收（回收的对象可以是弱引用的）。


[^5]: ## 理论基础

    *请看这里：[Generations (oracle.com)](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#distribution_lifetimes)*

    Hotspot 的开发者认为，对象的生命周期有两个关键特性（统计学）：

    * 弱分代：绝大多数对象都是临时对象，能够经历的 GC 次数非常少
    * 强分代：GC 次数越多的对象被下一次 GC 回收的概率越低

    所以，根据上述假说，我们可以得到两个内存布局的设计方式：

    * 年轻代：因为大多数对象都是“朝生夕灭”的，我们直接搞出一大块内存，等到装满了的时候，将所有活下来（未被回收）的对象拷贝到其他地方去，之后这块内存直接给下一轮新对象去用

      * 理解：因为年轻的对象消灭的比存活的少，比起对垃圾进行标记清除，还不如直接屎里淘金，然后按下冲水键
    * 老年代：因为能够经历很多次 GC 的对象更不容易被消灭了（还少），可以把它们放在一起，年轻代爱 GC 就 GC，老年代满了再标记清除（无法判断老年代中垃圾比率，而且对象数量也少）
    * 由于年轻代中，也不是所有的临时对象都只能活一天（有的是两天），最好安排个专属地方住（Survivor）


[^6]: # 标记-清除算法

    先标记所有要回收的对象，然后统一回收掉

    问题：

    * 标记和清除效率都不是很高
    * 标记清除后会有大量内存碎片，大对象无法找到连续内存空间分配


[^7]: # 复制算法

    将空间分为两块，一块内存用完了，就标记所有存活的对象复制到另一块，然后把当前块清空。

    问题：

    * 只有一半的可用空间

      * 但是根据 理论基础[^5]，实际上存放复制后存活对象的区域可以远远小于源区域
    * 复制是一件很耗时的事情

    Hotspot 将此算法用于新生代的 GC。


[^8]: # 标记-整理算法

    在 标记-清除算法[^6] 的基础上，将存活对象向一端移动。

    问题：

    * 还要复制，比标记-清除效率还低


[^9]: # Serial 收集器

    * 启动时 STW
    * 单线程复制
    * 单 CPU 环境（恐怕仅限此环境）效率更高


[^10]: # Parallel Scavenge 收集器

    `-XX:+UseParallelGC`

    * 吞吐量优先
    * 采用并行 复制算法[^7] 回收新生代
    * 老年代默认采用 Serial Old 收集器[^11]


[^11]: # Serial Old 收集器

    为 Serial 收集器[^9] 的老年代版本。单线程的 标记-整理算法[^8]。



[^12]: # ParNew 收集器

    `-XX:+UseParNewGC -XX:ParallelGCThreads={{n}}`

    * *和 Parallel Scavenge 有什么区别吗？*


[^13]: # Parallel Old 收集器

    `-XX:+UseParallelOldGC`

    * Parallel Scavenge 收集器[^10] 的老年版本
    * 多线程 标记-整理算法[^8]
    * *如何在多线程做到内存整理？*


[^14]: # CMS 收集器

    注意：此收集器最新版本的 JDK 已不再建议使用

    `-XX:+UseConcMarkSweepGC`

    * 可以并发收集，且延迟低
    * 采用 标记-清除算法[^6]
    * **​CPU 敏感**
    * **产生内存碎片，导致大对象 OOM**
    * **内存不能填满后 GC**（有 GC 阈值）

    ## 收集 4 阶段

    1. 初始标记 (Initial-Mark)

        * 标记于 GCRoots 直接关联的对象
        * 会 STW，但是时间很短
    2. 并发标记 (Concurrent-Mark)

        * 通过直接关联对象遍历对象图
        * 不会 STW
    3. 重新标记 (Remark)

        * 修正并发标记期间的改动

          * 主要是处理并发标记期间创建的新对象
        * 会 STW，比初始标记时间更长
    4. 并发清除 (Concurrent-Sweep)

        * 清除被判断为死亡的对象并释放内存
        * 和用户线程完全并发



[^15]: # Garbage-First (G1) 回收器

    里程碑式的收集器，面向服务端，面向局部收集的垃圾回收器。

    问题：

    * JDK 8 之后才被官方称作“全功能的垃圾收集器”
    * JDK 9 及之后才被 Oracle 设置为默认的垃圾收集器

    特点：

    * 并行且并发
    * 多代收集（整堆收集）
    * 空间整合：局部不会产生内存碎片
    * 可预测的停顿：在效率降低的同时，可以让使用者明确指定消耗在 GC 上的时间

    G1 GC 的四阶段和 CMS 是一样的，不再赘述。但是 G1 有三种模式，Young GC, Mixed GC 和 Full GC，在不同条件下触发。

    ## 参数

    `-XX:+UseG1GC`

    `-XX:MaxGCPauseMillis=%d`: 可预测的停顿：在效率降低的同时，可以让使用者明确指定消耗在 GC 上的时间[^16]，JVM 会尽力实现（默认 200 ms）

    `-XX:ParallelGCThreads=%d`: STW期间的GC工作线程数

    `-XX:ConcGCThreads=%d`: 非STW期间的GC工作线程数

    `-XX:G1HeapRegionSize`: G1 收集器取消了各代的物理划分，将堆进行了分区 (Region)，分代在分区中逻辑存在。[^17] 大小（默认 2048 块）

    `-XX:G1NewSizePercent`: 新生代大小下限（默认 5%）

    `-XX:G1MaxNewSizePercent`: 新生代大小上限（默认 60%）

    `-XX:InitiatingHeapOccupancyPercent`: 触发全局并发标记的老年代使用占比（默认 45%）

    ## 内存划分

    G1 收集器取消了这是为了对老年代进行并发回收（参见 G1）[^18]，将堆进行了分区 (Region)，分代在分区中逻辑存在。

    ## 局部复制

    G1 新生代垃圾收集还是会 STW，将存活对象拷贝到老年代或者 Survivor 空间。而复制区域的同时，G1 会完成堆的清理，不会产生内存碎片问题。

    需要注意，由于短期存在的巨型对象话剧i造成影响，G1 对超过分区容量 50% 以上的巨型对象（逻辑上位于老年代）新增了一种 由于大对象不能进行放在一个块里，增加了 Humongous 区[^19]。如果一个 H 区无法容纳，则分配连续的多个 H 区容纳一个巨型对象。


[^16]: * 可预测的停顿：在效率降低的同时，可以让使用者明确指定消耗在 GC 上的时间


[^17]: G1 收集器取消了这是为了对老年代进行并发回收（参见 G1）[^18]，将堆进行了分区 (Region)，分代在分区中逻辑存在。


[^18]: * 这是为了对老年代进行并发回收（参见 G1）


[^19]: * 由于大对象不能进行放在一个块里，增加了 Humongous 区


[^20]: # ZGC 收集器

    `-XX:UseZGC`

    特征：

    * 并发
    * 基于 Region
    * 压缩
    * NUMA 感知
    * 使用彩色指针
    * 使用负载屏障
